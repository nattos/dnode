const float2 texelSize = 1.0 / GetTextureSizeFloat(MainTex);
const int weightCount = 4;
const float rawWeight0 = 1.0f;
const float rawWeight1 = 0.9f;
const float rawWeight2 = 0.55f;
const float rawWeight3 = 0.18f;
const float rawWeight4 = 0.1f;
const float normalization = 1.0 / (2.0 * (rawWeight1 + rawWeight2 + rawWeight3 + rawWeight4));
const float weight0 = rawWeight0 * normalization;
const float weights[weightCount] = {
    rawWeight1 * normalization,
    rawWeight2 * normalization,
    rawWeight3 * normalization,
    rawWeight4 * normalization,
};

float2 center = gid_xy_norm;

bool isY = Axis;
const float firstWeightStep = rawWeight2 / rawWeight1;

int stages = Stages;
float stageOffset = StageOffset;
float step = Step;
float fineStages = FineStages;

int stage = 0;
float4 acc = 0.0;
float totalWeight = 0;
for (int stage = 0; stage < stages; ++stage) {
  float weightAdjust = mix(1.0, firstWeightStep, stage / (float)stages);
  if (stage == stages - 1) {
    weightAdjust *= fineStages;
  }

  float offset;
  offset = step * stageOffset * (stage + 0.75);
  float4 stageAcc = 0;
  for (int i = 0; i < weightCount; ++i) {
    float2 uv = center;
    if (isY) {
      uv.y += offset;
    } else {
      uv.x += offset;
    }
    stageAcc += SampleTexture<filter::linear, address::clamp_to_edge>(MainTex, uv) * weights[i];
    offset += step;
  }
  offset = step * -stageOffset * (stage + 0.75);
  for (int i = 0; i < weightCount; ++i) {
    float2 uv = center;
    if (isY) {
      uv.y += offset;
    } else {
      uv.x += offset;
    }
    stageAcc += SampleTexture<filter::linear, address::clamp_to_edge>(MainTex, uv) * weights[i];
    offset -= step;
  }
  acc += stageAcc * weightAdjust;
  totalWeight += weightAdjust;
}
acc /= max(1.0, totalWeight);
out = acc;
